# YAML文件延迟保存机制

## 背景

在系统中，我们使用YAML文件来保存游戏节点、游戏卡片、游戏实例等数据。这些数据会根据用户操作、节点状态变化和指标更新等原因频繁变化，尤其是在游戏节点的指标报告和状态更新方面，可能在短时间内触发多次保存操作。

每次保存操作都会带来文件系统I/O开销，会影响性能并增加磁盘负载。在高负载场景下，频繁的写入操作可能导致：

1. 系统性能下降
2. 磁盘I/O瓶颈
3. 过度消耗SSD写入寿命
4. 在写密集型环境中可能引起竞争条件

## 解决方案

我们设计并实现了一个延迟保存机制，可以将短时间内的多次保存请求合并为一次实际的文件写入操作。这种机制被称为防抖（Debounce）或节流（Throttle）。

### 核心组件

1. **DelayedSaver**：延迟保存器，提供基础的防抖功能
2. **YAMLSaver**：专门针对YAML文件的保存器，提供了更高级的功能

### 工作原理

1. 当调用Save方法时，不会立即进行文件写入，而是启动一个定时器（默认为1秒）
2. 如果在定时器到期前再次调用Save，则只会重置pending标志
3. 当定时器到期时，执行一次实际的文件写入操作
4. 如果在文件写入期间又有新的保存请求，会在写入完成后再次启动定时器

### 优势

1. **减少磁盘I/O**：将多次写入合并为一次，大幅减少文件系统操作
2. **提高性能**：减少磁盘I/O等待时间，提高系统响应速度
3. **延长SSD寿命**：减少写入次数，延长SSD的使用寿命
4. **原子性写入**：使用临时文件和重命名操作，确保写入的原子性，防止文件损坏
5. **简化使用**：通过封装，使用方无需关心延迟保存的具体实现

## 使用示例

```go
// 创建YAML保存器，使用1秒的延迟保存
saver := utils.NewYAMLSaver(
    dataFile,
    func() interface{} {
        // 返回需要保存的数据
        return myData
    },
    logger,
    utils.WithDelay(time.Second),
)

// 触发保存操作（不会立即写入文件）
err := saver.Save(ctx)
```

## 实现细节

### DelayedSaver

`DelayedSaver`是核心组件，提供通用的延迟保存机制：

- 使用`time.AfterFunc`创建延迟执行的定时器
- 使用互斥锁保护内部状态
- 提供`Save`、`Flush`和`Close`方法
- 支持上下文取消

### YAMLSaver

`YAMLSaver`是`DelayedSaver`的封装，提供YAML文件专用功能：

- 支持自定义延迟时间
- 支持自定义文件权限
- 使用临时文件和重命名操作确保原子性写入
- 提供数据提供函数，延迟获取最新数据

## 应用说明

已将此功能应用于以下存储实现：

- YAMLGameNodeStore
- YAMLGameCardStore
- YAMLGameInstanceStore
- YAMLGamePlatformStore
- YAMLGamePipelineStore

默认配置为1秒的延迟，可根据需要调整。

## 注意事项

1. 延迟保存机制适用于对写入时间不敏感的场景
2. 程序关闭前应调用`Close`方法，确保所有数据都已保存
3. 如需立即保存，可使用`SaveNow`方法绕过延迟机制
4. 延迟保存器使用的数据提供函数应返回最新数据，而不是保存时的数据快照 