# 节点 Agent 通信设计

## 1. 通信架构

### 1.1 总体架构

节点 Agent 通信系统采用客户端-服务器架构，基于 gRPC 实现。系统包含以下主要组件：

1. **中央服务器**：作为 gRPC 服务端，提供 API 接口供节点 Agent 调用
2. **节点 Agent**：部署在每个游戏节点上，作为 gRPC 客户端与中央服务器通信
3. **通信协议**：使用 Protocol Buffers 定义消息格式和服务接口

### 1.2 通信流程

```txt
┌─────────────┐                           ┌─────────────┐
│             │  1. 节点注册(Register)      │             │
│             │ ─────────────────────────> │             │
│             │                           │             │
│             │  2. 心跳(Heartbeat)        │             │
│  节点Agent   │ <────────────────────────> │ 中央服务器  │
│             │                           │             │
│             │  3. 命令执行(Execute*)      │             │
│             │ <────────────────────────> │             │
│             │                           │             │
│             │  4. 事件流(Events)         │             │
│             │ <─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ │             │
└─────────────┘                           └─────────────┘
```

### 1.3 核心功能

1. **节点注册与心跳**：Agent 启动后向服务器注册，并定期发送心跳保持连接
2. **Pipeline 执行**：服务器向 Agent 下发 Pipeline，Agent 执行并反馈状态
3. **容器管理**：服务器可远程控制 Agent 上的容器生命周期
4. **状态监控**：Agent 定期上报节点资源使用情况和容器状态
5. **日志流**：Agent 实时上传节点和容器日志
6. **事件流**：服务器订阅 Agent 的各类事件通知

### 1.4 Pipeline详解

1. **Pipeline**：Pipeline应该包括名称name、环境变量envs、数据卷volumes、步骤steps，Pipeline采用yaml设计与传输；
2. **Steps**: 包括上传下载S3或HTTP数据，压缩或解压指定文件，启动或停止容器等等，每个Step都由一个容器镜像具体负责执行；
3. **Envs**: S3存储的地址，访问Key,Value这些都保存在平台，通过环境变量传递给Pipeline，所以不需要明文传输秘密凭据数据；
4. **Volumes**: 数据卷，Pipeline将为每个步骤的执行程序分配数据卷，不是分配的不允许访问。
5. **Args**: Pipeline将会通过API来获取对象的静态属性，然后Steps中可以引用这些静态属性。
6. 回写数据: Pipeline将会回写状态信息，如容器启动的http端口，容器绑定的数据目录在主机上的地址，这些都是pipeline运行时根据指定条件生成的，所以需要回写。

## 2. 双向通信机制

### 2.1 请求-响应模式

用于简单的命令下发和状态查询：

1. **注册(Register)**：Agent 启动时向服务器注册，获取 session_id
2. **心跳(Heartbeat)**：Agent 定期发送心跳，附带基本状态信息
3. **命令执行**：如启动容器(StartContainer)、执行 Pipeline(ExecutePipeline)等

### 2.2 服务器流模式

用于服务器持续接收 Agent 发送的数据流：

1. **日志流(StreamNodeLogs, StreamContainerLogs)**：Agent 将日志实时发送给服务器
2. **监控指标流**：Agent 定期上报详细的资源使用情况

### 2.3 客户端流模式

用于 Agent 持续向服务器发送数据：

1. **批量事件上报**：Agent 将多个事件批量发送给服务器
2. **文件上传**：Agent 将大文件分块上传到服务器

### 2.4 双向流模式

用于实时交互的场景：

1. **事件订阅(SubscribeEvents)**：服务器订阅 Agent 的事件，Agent 实时推送事件通知
2. **远程控制会话**：服务器与 Agent 建立长连接交互会话

## 3. 错误处理与重试策略

### 3.1 通信错误分类

1. **临时性错误**：网络抖动、服务器暂时不可用等
2. **持久性错误**：认证失败、权限不足、参数无效等
3. **超时错误**：请求超过预定时间未得到响应

### 3.2 重试策略

1. **指数退避算法**：

   - 初始重试等待时间：100ms
   - 最大重试等待时间：30s
   - 随机抖动因子：0.2 (±20%)
   - 最大重试次数：5 次

2. **临时性错误处理**：

   - 应用指数退避重试
   - 错误日志记录
   - 重试计数

3. **持久性错误处理**：

   - 不进行重试
   - 错误日志记录
   - 错误上报给服务器

4. **超时错误处理**：
   - 针对幂等操作应用重试策略
   - 非幂等操作需谨慎重试，确认操作状态

### 3.3 错误恢复机制

1. **会话恢复**：

   - Agent 在连接断开后尝试重连
   - 使用上一次的 session_id 尝试恢复会话
   - 如果会话无效，则重新注册

2. **状态同步**：

   - 重连成功后，Agent 发送完整的状态报告
   - 服务器与 Agent 进行状态对比和同步
   - 对已下发但未确认完成的任务进行状态查询

3. **任务幂等性**：
   - 所有重要操作都设计为幂等操作
   - 使用唯一标识符防止重复执行
   - 操作执行前检查状态，避免重复操作

## 4. 安全机制

### 4.1 认证与授权

1. **TLS 加密**：

   - 所有通信使用 TLS 加密
   - 证书验证确保服务端身份

2. **节点认证**：

   - 每个节点分配唯一的节点 ID 和认证令牌
   - 注册时进行身份验证
   - 心跳消息包含认证信息

3. **访问控制**：
   - 基于角色的权限控制
   - 操作审计日志
   - 敏感操作需要额外授权

### 4.2 数据保护

1. **敏感信息处理**：

   - 不在日志中记录敏感信息
   - 密码和令牌等敏感数据加密存储
   - 传输中的敏感数据加密

2. **数据完整性**：
   - 消息摘要验证
   - 校验和验证文件完整性
   - 版本控制防止数据覆盖

## 5. 性能优化

### 5.1 连接管理

1. **连接池**：

   - 复用 gRPC 连接
   - 动态调整连接数量
   - 定期清理空闲连接

2. **流控制**：
   - 客户端限制并发请求数
   - 服务端限制请求处理速率
   - 背压机制防止过载

### 5.2 数据优化

1. **批处理**：

   - 批量发送小消息
   - 合并相似请求
   - 异步处理非关键消息

2. **压缩**：

   - 对日志和大数据包启用压缩
   - 选择合适的压缩算法
   - 动态调整压缩级别

3. **缓存**：
   - 缓存频繁请求的响应
   - 状态变更增量更新
   - 预取可能需要的数据
